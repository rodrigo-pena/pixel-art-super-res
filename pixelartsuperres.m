function [ large_img ] = pixelartsuperres( small_img, factor )
% PIXELARTSUPERRES output a higher-resolution version a pixel-art image
% computed based on the EPX algorith. It doubles small_img resolution at
% each iteration, until the super-resolution factor entered by the user is
% attained.
%
%   Input:
%       small_img   :   A pixel-art image to be expanded
%       factor      :   The super-resolution factor, such that
%                       size(large_img) = factor * size(small_img). It has
%                       to be a power of two.
%
%   Output:
%       large_img   :   The expanded version of small_img
%
%   Example:
%       small_img = imread('img/1.tif');
%       factor = 4;
%       large_img = pixelartsuperres(small_img, factor)
%       figure;
%       subplot(121)
%       imshow(small_img);
%       title('Original');
%       subplot(122)
%       imshow(large_img);
%       title('Expanded');
%
%   Details:
%       Inicially, each pixel P in the original image is expanded to a 2x2
%       block, whose pixel intensities are the same as that of P. The
%       neighborhood of P is analyzed to assign new intensity values to the
%       pixels in the 2x2 block generated by P
%
%       From the original image:                     To the expanded image:
%                 |A|
%               |C|P|B|                --\                  |P1|P2|
%                 |D|                  --/                  |P3|P4|
%
%       If A and C are similar, P1 <- (A + C)/2. Otherwise, P1 <- P. The
%       same analysis is carried on for the pairs (A,B), (B,D), and (C,D)
%       to establish the intensities of P2, P4, and P3, respectively.
%
%       Two pixels are similar if their difference in the Y, Cb, and Cr
%       channels are less than 48, 3 e 3, respectively.
%
% Authors: Gabriel Trevisan
%          Rodrigo Pena
% Date: 21 Nov 2011
% Testing: test_pixelartsuperres.m

%% Parse input

% small_img
small_img = double(small_img);
[r, c, d] = size(small_img);
assert(d == 1 || d == 3, 'small_img must have 1 or 3 channels');

% factor
[f, ~] = log2(factor);
assert(f == 0.5, 'factor must be a power of 2');

% Channel difference constants for pixel similarity assessment
if d == 3
    Ly = 48; % Y limit
    Lcb = 3; % Cb limit
    Lcr = 3; % Cr limit
else
    Ly = 48; % Y limit
    Lcb = 48; % Cb limit
    Lcr = 48; % Cr limit
end

%% Iterative doubling
for k = 1:log2(factor)
    
    % Initialization
    img_nearest = imresize(small_img, 2, 'nearest');
    large_img = img_nearest;
    if d == 3
        YCbCr = rgb2ycbcr(small_img);
        Y = YCbCr(:,:,1);
        Cb = YCbCr(:,:,2);
        Cr = YCbCr(:,:,3);
    else
        Y = small_img;
        Cb = small_img;
        Cr = small_img;
    end
    
    % Sweep the pixels in the original image
    for i = 1:r
        for j = 1:c
            
            % If the current pixel (P) is not on the border
            if (i < r) && (j < c) && (i > 1) && (j > 1)
                A = small_img(i-1,j,:);
                B = small_img(i,j+1,:);
                C = small_img(i,j-1,:);
                D = small_img(i+1,j,:);
                
                % If the neighbor pixels are different horizontally and
                % vertically
                if (sum(A~=D) > 1) && (sum(B~=C) > 1)
                    
                    % Assign a new value to P2
                    if (abs(Y(i-1,j)-Y(i,j+1)) < Ly) && ...
                            (abs(Cb(i-1,j)-Cb(i,j+1)) < Lcb) && ...
                            (abs(Cr(i-1,j)-Cr(i,j+1)) < Lcr)
                        
                        large_img(2*(i-1)+1, 2*j, :)= round((A + B)/2);
                    end
                    
                    % Assign a new value to P3
                    if (abs(Y(i,j+1)-Y(i+1,j)) < Ly) && ...
                            (abs(Cb(i,j+1)-Cb(i+1,j)) < Lcb) && ...
                            (abs(Cr(i,j+1)-Cr(i+1,j)) < Lcr)
                        
                        large_img(2*i, 2*j, :)= round((B + D)/2);
                    end
                    
                    % Assign a new value to P4
                    if (abs(Y(i,j-1)-Y(i+1,j)) < Ly) && ...
                            (abs(Cb(i,j-1)-Cb(i+1,j)) < Lcb) && ...
                            (abs(Cr(i,j-1)-Cr(i+1,j)) < Lcr)
                        
                        large_img(2*i, 2*(j-1)+1, :) = round((D + C)/2);
                    end
                    
                    % Assign a new value to P1
                    if (abs(Y(i-1,j)-Y(i,j-1)) < Ly) && ...
                            (abs(Cb(i-1,j)-Cb(i,j-1)) < Lcb) && ...
                            (abs(Cr(i-1,j)-Cr(i,j-1)) < Lcr)
                        
                        large_img(2*(i-1)+1, 2*(j-1)+1, :) = ...
                            round((C + A)/2);
                    end
                    
                end
                
            end
            
        end
    end
    
    [large_img, ~] = solve_ambiguities(large_img, img_nearest);
    
    % Assign this iteration's large_img as the next iteration's small_img
    small_img = large_img;
    [r, c, d] = size(small_img);
    
end

large_img = uint8(large_img);

end

